<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zoy Jogos - Labirinto com Níveis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // Configuração do Tailwind para usar a fonte Inter e cores personalizadas
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
            },
            colors: {
              "zoy-blue": "#1e40af",
              "zoy-dark": "#0f172a",
              "zoy-light": "#f1f5f9",
              "panda-color": "#34d399",
            },
          },
        },
      };
    </script>
    <link rel="stylesheet" href="static/css/home.css" />
    <style>
      /* Estilos específicos para a tela de jogos */
      body,
      html {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: "Inter", sans-serif;
        background-color: #f0f4f8;
      }

      /* Layout principal: 100% da viewport */
      #mainContainer {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      /* Área do jogo: Flexível e centralizada */
      #gameArea {
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #ffffff;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        padding: 1rem;
        max-width: 960px; /* Limite o tamanho total para telas grandes */
        width: 100%;
        margin: 0 auto; /* Centraliza a área do jogo */
      }

      /* Área do Blockly */
      #blocklyDiv {
        height: 80vh;
        width: 100%;
      }

      /* Terminal de Status */
      #statusMessage {
        transition: all 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div id="mainContainer" class="p-4">
      <header class="mb-4">
        <h1 class="text-3xl font-bold text-zoy-dark">
          Zoy Jogos - Programação Labirinto
        </h1>
      </header>

      <div
        class="flex flex-col md:flex-row justify-between items-center mb-4 space-y-2 md:space-y-0"
      >
        <select
          id="difficultySelector"
          onchange="window.setDifficulty(this.value); window.resetGame();"
          class="p-2 border rounded shadow-sm"
        >
          <option value="easy">Fácil (5x5)</option>
          <option value="medium">Médio (7x7)</option>
          <option value="hard">Difícil (9x9)</option>
        </select>

        <div class="flex space-x-2">
          <button
            id="btnExecutarPrograma"
            onclick="window.executeProgram()"
            class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded shadow"
          >
            Executar Programa
          </button>
          <button
            id="btnPararPrograma"
            onclick="window.stopProgram()"
            class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded shadow"
            disabled
          >
            Parar
          </button>
          <button
            id="btnResetar"
            onclick="window.resetGame()"
            class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded shadow"
          >
            Resetar
          </button>
        </div>
      </div>

      <div
        id="statusMessage"
        class="p-2 text-center rounded mb-4 bg-gray-200 text-gray-700"
      >
        Aguardando a inicialização do jogo...
      </div>

      <div
        class="flex-1 flex flex-col lg:flex-row space-y-4 lg:space-y-0 lg:space-x-4"
      >
        <div
          id="gameContainer"
          class="w-full lg:w-1/2 flex justify-center items-center"
        >
          <div id="gameArea">
            <canvas id="gameCanvas" class="border border-gray-300"></canvas>
          </div>
        </div>

        <div id="blocklyContainer" class="w-full lg:w-1/2">
          <div
            id="blocklyDiv"
            class="shadow-lg border border-gray-300 rounded"
          ></div>
        </div>
      </div>
    </div>

    <script>
      // --- VARIÁVEIS DE ESTADO DO JOGO ---
      let canvas, ctx;
      let maze = [];
      let player = { row: 0, col: 0, angle: 0 }; // angle: 0=Up, 90=Right, 180=Down, 270=Left
      let cellSize = 0;
      let isRunning = false;
      let currentDifficulty = "easy";

      const difficulties = {
        easy: { size: 5, start: [0, 0], end: [4, 4] },
        medium: { size: 7, start: [0, 0], end: [6, 6] },
        hard: { size: 9, start: [0, 0], end: [8, 8] },
      };

      // --- FUNÇÕES GLOBAIS DE JOGO (Chamadas pelo código gerado do Blockly) ---

      /**
       * Atualiza a mensagem de status na tela.
       */
      window.updateStatus = function (
        message,
        bgClass = "bg-blue-100",
        textClass = "text-blue-700"
      ) {
        const statusElement = document.getElementById("statusMessage");
        if (statusElement) {
          // Limpa classes anteriores de cor
          statusElement.className = "";
          statusElement.classList.add(
            "p-2",
            "text-center",
            "rounded",
            "mb-4",
            bgClass,
            textClass
          );
          statusElement.textContent = message;
        }
      };

      /**
       * Gera um labirinto simples (pode ser substituído por um algoritmo mais complexo)
       */
      // zoy_jogos.html (Dentro da tag <script>)

      function generateSimpleMaze(size) {
        let newMaze = Array(size)
          .fill(0)
          .map(() => Array(size).fill(0));

        // --- LÓGICA DE PAREDES AJUSTADA ---
        if (size >= 5) {
          // Garantindo que (0, 1) é livre para a primeira jogada para a direita
          newMaze[0][1] = 0;

          // Mantendo as paredes existentes em outro lugar para não ser um caminho reto
          newMaze[1][2] = 1;
          newMaze[3][2] = 1;
          // Colocando uma parede na linha 0, coluna 3 (evita caminho reto)
          newMaze[0][3] = 1;
        }
        // ... (o resto da lógica de labirinto para 7x7 e 9x9 pode ser ajustado da mesma forma)

        const { start, end } = difficulties[currentDifficulty];
        newMaze[start[0]][start[1]] = 0;
        newMaze[end[0]][end[1]] = 0;

        return newMaze;
      }
      /**
       * Reseta o estado do jogo (posição do jogador e labirinto)
       */
      window.resetGame = function () {
        window.updateStatus("Jogo resetado. Construa seu programa!");
        const { size, start } = difficulties[currentDifficulty];
        maze = generateSimpleMaze(size);
        //player = { row: start[0], col: start[1], angle: 0 };
        player = { row: start[0], col: start[1], angle: 90 };

        window.isRunning = false;

        // Limpa o workspace (se estiver inicializado)
        if (window.workspaceMaze) {
         // window.workspaceMaze.clear();
        }

        // Desenha o labirinto inicial
        drawMaze();

        // Reseta botões
        document.getElementById("btnExecutarPrograma").disabled = false;
        document.getElementById("btnPararPrograma").disabled = true;
      };

      /**
       * Define a dificuldade e reseta o jogo. Chamada pelo selector no HTML.
       */
      window.setDifficulty = function (difficulty) {
        if (difficulties[difficulty]) {
          currentDifficulty = difficulty;
        }
      };

      /**
       * Move o jogador para frente se for possível. Chamada pelo código gerado do Blockly.
       */
      // zoy_jogos.html (Dentro da tag <script>)

      window.moveForward = function () {
        let newRow = player.row;
        let newCol = player.col;

        // LÓGICA ATUALIZADA (Certifique-se de que a lógica corresponda ao ângulo):
        if (player.angle === 0) {
          newRow--; // 0 (Cima) -> Linha diminui
        } else if (player.angle === 90) {
          newCol++; // 90 (Direita) -> Coluna aumenta
        } else if (player.angle === 180) {
          newRow++; // 180 (Baixo) -> Linha aumenta
        } else if (player.angle === 270) {
          newCol--; // 270 (Esquerda) -> Coluna diminui
        }
        // FIM DA LÓGICA ATUALIZADA

        // ... (O resto da função continua igual: verificação de limites e paredes)
        if (
          newRow >= 0 &&
          newRow < maze.length &&
          newCol >= 0 &&
          newCol < maze.length &&
          maze[newRow][newCol] === 0
        ) {
          player.row = newRow;
          player.col = newCol;
          drawMaze();
          return true;
        }

        window.updateStatus(
          "Movimento bloqueado! (Parede ou limite)",
          "bg-red-500",
          "text-white"
        );
        window.stopProgram(); // Interrompe a execução ao bater na parede
        return false;
      };
      /**
       * Gira o jogador. Chamada pelo código gerado do Blockly.
       */
      window.turn = function (direction) {
        if (direction === "LEFT") {
          player.angle = (player.angle + 270) % 360; // -90 graus
        } else if (direction === "RIGHT") {
          player.angle = (player.angle + 90) % 360; // +90 graus
        }
        drawMaze(); // Redesenha após o giro
        return true;
      };

      /**
       * Verifica se há um caminho livre na frente. Chamada pelo código gerado do Blockly.
       */
      window.isPathForward = function () {
        let nextRow = player.row;
        let nextCol = player.col;

        // 0=Up (-row), 90=Right (+col), 180=Down (+row), 270=Left (-col)
        if (player.angle === 0) nextRow--;
        else if (player.angle === 90) nextCol++;
        else if (player.angle === 180) nextRow++;
        else if (player.angle === 270) nextCol--;

        // Retorna true se estiver dentro dos limites e não for uma parede
        return (
          nextRow >= 0 &&
          nextRow < maze.length &&
          nextCol >= 0 &&
          nextCol < maze.length &&
          maze[nextRow][nextCol] === 0
        );
      };

      /**
       * Verifica se o jogador chegou ao ponto final. Chamada pelo código gerado do Blockly.
       */
      window.isPathGoal = function () {
        const { end } = difficulties[currentDifficulty];
        return player.row === end[0] && player.col === end[1];
      };

      // --- FUNÇÕES DE RENDERIZAÇÃO DO CANVAS ---

      function drawMaze() {
        if (!ctx || !canvas) return;

        const size = maze.length;
        cellSize = canvas.width / size;

        // 1. Limpa o Canvas
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Desenha o Labirinto (Paredes)
        ctx.strokeStyle = "#374151"; // Cor da parede
        ctx.lineWidth = 2;

        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            if (maze[r][c] === 1) {
              ctx.fillStyle = "#4b5563"; // Parede
              ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
            } else {
              // Desenha as linhas da grade
              ctx.strokeRect(c * cellSize, r * cellSize, cellSize, cellSize);
            }
          }
        }

        // 3. Desenha Ponto de Início (Start) e Fim (Goal)
        const { start, end } = difficulties[currentDifficulty];

        // Início
        ctx.fillStyle = "#22c55e"; // Verde
        ctx.fillRect(
          start[1] * cellSize,
          start[0] * cellSize,
          cellSize,
          cellSize
        );

        // Fim
        ctx.fillStyle = "#ef4444"; // Vermelho
        ctx.fillRect(end[1] * cellSize, end[0] * cellSize, cellSize, cellSize);

        // 4. Desenha o Jogador
        const playerX = player.col * cellSize + cellSize / 2;
        const playerY = player.row * cellSize + cellSize / 2;
        const playerSize = cellSize * 0.4; // Tamanho do triângulo

        ctx.fillStyle = "#1e40af"; // Azul do Zoy
        ctx.beginPath();

        // Salva o estado atual do canvas (para rotação)
        ctx.save();
        ctx.translate(playerX, playerY);
        ctx.rotate((player.angle * Math.PI) / 180); // Rotação

        // Desenha um triângulo (representa a direção)
        ctx.moveTo(0, -playerSize / 2); // Ponta (frente)
        ctx.lineTo(playerSize / 2, playerSize / 2); // Canto inferior direito
        ctx.lineTo(-playerSize / 2, playerSize / 2); // Canto inferior esquerdo
        ctx.closePath();
        ctx.fill();

        // Restaura o estado original (desfaz a translação e rotação)
        ctx.restore();

        // Verifica se o jogo acabou
        if (window.isPathGoal()) {
          window.updateStatus(
            "Parabéns! Você chegou ao destino!",
            "bg-green-500",
            "text-white"
          );
          window.stopProgram();
        }
      }

      // --- INICIALIZAÇÃO E REDIMENSIONAMENTO DO AMBIENTE DE JOGO ---

      function resizeCanvas() {
        const container = document.getElementById("gameContainer");
        if (!container || !canvas) return;

        // Garante que o canvas seja quadrado e se ajuste à área
        // Usa o tamanho do contêiner do jogo, limitado a uma altura razoável
        const size = Math.min(
          container.clientWidth * 0.9,
          window.innerHeight * 0.5
        );
        canvas.width = size;
        canvas.height = size;
        drawMaze();
      }

      function initGameEnvironment() {
        canvas = document.getElementById("gameCanvas");

        if (!canvas) {
          console.error("Canvas não encontrado.");
          return;
        }

        ctx = canvas.getContext("2d");

        window.addEventListener("resize", resizeCanvas);

        // Define a dificuldade inicial (padrão 'easy')
        window.setDifficulty(
          document.getElementById("difficultySelector").value
        );
        resizeCanvas();

        // O resetGame será chamado pelo script zoy_jogos.js após o Blockly carregar
      }

      document.addEventListener("DOMContentLoaded", initGameEnvironment);
    </script>

    <script src="static/lib/blockly/blockly.min.js"></script>
    <script src="static/lib/blockly/python_compressed.js"></script>
    <script src="zoy_jogos.js"></script>
  </body>
</html>
